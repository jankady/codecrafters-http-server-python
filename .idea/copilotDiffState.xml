<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/main.py" />
              <option name="originalContent" value="import argparse&#10;import socket  # noqa: F401&#10;import os&#10;import gzip&#10;import threading&#10;&#10;def check_file_exists(path_to_file, directory):&#10;    get_file = os.path.basename(path_to_file)&#10;&#10;    try:&#10;        files_in_directory = os.listdir(directory)  # list of files in the directory&#10;        if get_file in files_in_directory:&#10;            return True&#10;    except Exception:&#10;        return False&#10;&#10;    return False&#10;&#10;&#10;def check_directory_exists(directory):&#10;    try:&#10;        if os.path.exists(directory) and os.path.isdir(directory):&#10;            return True&#10;    except Exception:&#10;        return False&#10;&#10;    return False&#10;&#10;&#10;def create_file(path_to_file, directory, content_type, content_length, content_body):&#10;    get_file = os.path.basename(path_to_file)&#10;    target_file = os.path.join(directory, get_file)&#10;&#10;    try:&#10;        with open(target_file, 'w') as file:&#10;            file.write(content_body)&#10;        return True&#10;    except Exception:&#10;        return False&#10;&#10;    return False&#10;&#10;&#10;def validate_encoding(encoding_type):&#10;    result = []&#10;    for encoding in encoding_type:&#10;        if encoding in [&quot;gzip&quot;, &quot;deflate&quot;, &quot;br&quot;]:&#10;            result.append(encoding)&#10;    return result&#10;&#10;&#10;def gzip_encode(data):&#10;    compressed_data = gzip.compress(data if isinstance(data, bytes) else data.encode())&#10;    return compressed_data&#10;&#10;def generate_response(http_method, http_full_path, http_version, host,&#10;                      content_type, content_length, user_agent, request_body, directory, encoding_type, connection):&#10;&#10;    connection_close = &quot;&quot;&#10;    if connection == &quot;close&quot;:&#10;        connection_close = &quot;Connection: close\r\n&quot;&#10;&#10;    http_response = b&quot;&quot;&#10;    match http_method:&#10;        case &quot;GET&quot;:&#10;            if check_file_exists(http_full_path, directory):&#10;                target_file = os.path.join(directory, os.path.basename(http_full_path))&#10;                http_code = &quot;200 OK&quot;&#10;                with open(target_file, 'r') as file:&#10;                    response_body = file.read()&#10;                content_type = &quot;application/octet-stream&quot;&#10;                content_length = os.path.getsize(target_file)&#10;&#10;                http_response = (&#10;                    f&quot;{http_version} {http_code}\r\n&quot;&#10;                    f&quot;Content-Type: {content_type}\r\n&quot;&#10;                    f&quot;Content-Length: {content_length}\r\n&quot;&#10;                    f&quot;{connection_close}&quot;&#10;                    f&quot;\r\n&quot;&#10;                    f&quot;{response_body}&quot;&#10;                ).encode()&#10;&#10;            elif http_full_path.split(&quot;/&quot;)[1] == &quot;echo&quot;:&#10;                http_code = &quot;200 OK&quot;&#10;                content_type = &quot;text/plain&quot;&#10;                content_length = len(http_full_path.split(&quot;/&quot;)[2])&#10;                response_body = http_full_path.split(&quot;/&quot;)[2]&#10;                encoding_list = validate_encoding(encoding_type)&#10;&#10;                if len(encoding_list) &gt; 0:&#10;                    content_encoding = &quot;, &quot;.join(encoding_list)&#10;                    compresed_body = gzip_encode(response_body)&#10;                    http_response = (&#10;                        f&quot;{http_version} {http_code}\r\n&quot;&#10;                        f&quot;Content-Encoding: {content_encoding}\r\n&quot;&#10;                        f&quot;Content-Type: {content_type}\r\n&quot;&#10;                        f&quot;Content-Length: {len(compresed_body)}\r\n&quot;&#10;                        f&quot;{connection_close}&quot;&#10;                        f&quot;\r\n&quot;&#10;                    ).encode() + compresed_body&#10;                else:&#10;                    http_response = (&#10;                        f&quot;{http_version} {http_code}\r\n&quot;&#10;                        f&quot;Content-Type: {content_type}\r\n&quot;&#10;                        f&quot;Content-Length: {content_length}\r\n&quot;&#10;                        f&quot;{connection_close}&quot;&#10;                        f&quot;\r\n&quot;&#10;                        f&quot;{response_body}&quot;&#10;                    ).encode()&#10;&#10;            elif user_agent is not None:&#10;                http_code = &quot;200 OK&quot;&#10;                content_type = &quot;text/plain&quot;&#10;                response_body = user_agent&#10;                content_length = len(response_body)&#10;                http_response = (&#10;                    f&quot;{http_version} {http_code}\r\n&quot;&#10;                    f&quot;Content-Type: {content_type}\r\n&quot;&#10;                    f&quot;Content-Length: {content_length}\r\n&quot;&#10;                    f&quot;{connection_close}&quot;&#10;                    f&quot;\r\n&quot;&#10;                    f&quot;{response_body}&quot;&#10;                ).encode()&#10;            elif http_full_path == &quot;/&quot;:&#10;                http_code = &quot;200 OK&quot;&#10;&#10;                http_response = (&#10;                    f&quot;{http_version} {http_code}\r\n&quot;&#10;                    f&quot;{connection_close}&quot;&#10;                    f&quot;\r\n&quot;&#10;                ).encode()&#10;            else:&#10;                http_code = &quot;404 Not Found&quot;&#10;                http_response = (&#10;                    f&quot;{http_version} {http_code}\r\n\r\n&quot;&#10;                    f&quot;{connection_close}&quot;&#10;                ).encode()&#10;&#10;        case &quot;POST&quot;:&#10;            if check_directory_exists(directory):&#10;                create_file(http_full_path, directory, content_type, content_length, request_body)&#10;                http_code = &quot;201 Created&quot;&#10;                http_response = (&#10;                    f&quot;{http_version} {http_code}\r\n&quot;&#10;                    f&quot;{connection_close}&quot;&#10;                    f&quot;\r\n&quot;&#10;                ).encode()&#10;&#10;            else:&#10;                http_code = &quot;404 Not Found&quot;&#10;                http_response = (&#10;                    f&quot;{http_version} {http_code}\r\n\r\n&quot;&#10;                    f&quot;{connection_close}&quot;&#10;                ).encode()&#10;&#10;    return http_response&#10;&#10;&#10;def parse_request(request):&#10;    sections = request.split(&quot;\r\n&quot;)&#10;    request_line = sections[0].split(&quot; &quot;)&#10;    method = request_line[0]&#10;    path = request_line[1]&#10;    version = request_line[2]&#10;&#10;    header_host = None&#10;    content_length = 0&#10;    content_type = None&#10;    user_agent = None&#10;    encoding_type = []&#10;    connection = None&#10;    for header in sections[1:]:&#10;        if header == &quot;&quot;:&#10;            break&#10;&#10;        if header.lower().startswith(&quot;host:&quot;):&#10;            header_host = header.split(&quot; &quot;, 1)[1].strip()&#10;        elif header.lower().startswith(&quot;content-length:&quot;):&#10;            content_length = int(header.split(&quot; &quot;, 1)[1].strip())&#10;        elif header.lower().startswith(&quot;content-type:&quot;):&#10;            content_type = header.split(&quot; &quot;, 1)[1].strip()&#10;        elif header.lower().startswith(&quot;user-agent:&quot;):&#10;            user_agent = header.split(&quot; &quot;, 1)[1].strip()&#10;        elif header.lower().startswith(&quot;accept-encoding:&quot;):&#10;            for enc in header.split(&quot; &quot;, 1)[1].strip().split(&quot;,&quot;):&#10;                encoding_type.append(enc.strip())&#10;        elif header.lower().startswith(&quot;connection:&quot;):&#10;            connection = header.split(&quot; &quot;, 1)[1].strip()&#10;&#10;    request_body = request.split(&quot;\r\n\r\n&quot;)[1] if &quot;\r\n\r\n&quot; in request else None&#10;    return method, path, version, header_host, content_type, content_length, user_agent, request_body, encoding_type, connection&#10;&#10;&#10;def handle_client(conn):&#10;    parser = argparse.ArgumentParser()&#10;    parser.add_argument(&quot;--directory&quot;, help=&quot;Host directory filepath&quot;)&#10;    args = parser.parse_args()&#10;&#10;&#10;    while True:&#10;        data = conn.recv(1024).decode().strip()&#10;        if not data:&#10;            print(&quot;1) Connection closed&quot;)&#10;            break&#10;&#10;        (http_method, http_full_path, http_version, host, content_type, content_length, user_agent,&#10;         request_body, encoding_type, connection) = parse_request(data)&#10;&#10;        http_response = generate_response(http_method, http_full_path, http_version, host, content_type,&#10;                                          content_length, user_agent, request_body, args.directory, encoding_type, connection)&#10;&#10;        conn.sendall(http_response)&#10;&#10;        if connection == &quot;close&quot;:&#10;            print(&quot;2) Connection close detected, closing connection.&quot;)&#10;            break&#10;&#10;    conn.close()&#10;&#10;&#10;def main():&#10;    # You can use print statements as follows for debugging, they'll be visible when running tests.&#10;    print(&quot;Logs from your program will appear here!&quot;)&#10;&#10;    server_socket = socket.create_server((&quot;localhost&quot;, 4221))&#10;&#10;&#10;    while True:&#10;        conn, addr = server_socket.accept()  # wait for client&#10;&#10;        threading.Thread(target=handle_client, args=(conn, )).start()&#10;        print(&quot;Started thread for client:&quot;, addr)&#10;&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Simple HTTP/1.1 server&#10;&#10;This module implements a tiny HTTP server intended for educational use and for&#10;the codecrafters exercise. It supports:&#10;- Basic GET and POST handling&#10;- Persistent TCP connections (reads multiple requests per connection)&#10;- Simple echo behaviour and basic file serving/creation inside a host directory&#10;&#10;Notes:&#10;- This is not a production-ready HTTP server. It intentionally keeps things&#10;  small and approachable for learning. There are many simplifications:&#10;  * limited header parsing&#10;  * no chunked transfer decoding&#10;  * naive Content-Length handling&#10;  * minimal security checks on paths&#10;&#10;The edits in this file are documentation only (docstrings and inline comments)&#10;and do not change runtime behaviour.&#10;&quot;&quot;&quot;&#10;&#10;import argparse&#10;import socket  # noqa: F401 - socket is used by server setup in main()&#10;import os&#10;import gzip&#10;import threading&#10;&#10;&#10;def check_file_exists(path_to_file, directory):&#10;    &quot;&quot;&quot;&#10;    Return True if a file (basename of `path_to_file`) exists in `directory`.&#10;&#10;    Args:&#10;        path_to_file (str): full or partial path; only basename is considered.&#10;        directory (str): directory to look into.&#10;&#10;    Returns:&#10;        bool: True when the file exists, False otherwise.&#10;    &quot;&quot;&quot;&#10;    get_file = os.path.basename(path_to_file)&#10;&#10;    try:&#10;        # Directly return the membership check; if listing fails, return False.&#10;        return get_file in os.listdir(directory)&#10;    except Exception:&#10;        # Any error while listing -&gt; treat as missing file.&#10;        return False&#10;&#10;&#10;def check_directory_exists(directory):&#10;    &quot;&quot;&quot;&#10;    Check whether `directory` exists and is a directory.&#10;&#10;    Args:&#10;        directory (str): path to check.&#10;&#10;    Returns:&#10;        bool: True if directory exists and is a directory.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Return the boolean expression directly; exceptions -&gt; False.&#10;        return os.path.exists(directory) and os.path.isdir(directory)&#10;    except Exception:&#10;        return False&#10;&#10;&#10;def create_file(path_to_file, directory, content_type, content_length, content_body):&#10;    &quot;&quot;&quot;&#10;    Create a file inside `directory` using the basename of `path_to_file`.&#10;&#10;    This helper performs a straightforward text write. It is intentionally&#10;    simple for the exercise. The function ignores `content_type` and&#10;    `content_length` and writes `content_body` as a text file.&#10;&#10;    Args:&#10;        path_to_file (str): requested path (only basename is used to create a file).&#10;        directory (str): directory where the file will be created.&#10;        content_type (str): unused (kept for compatibility with earlier signatures).&#10;        content_length (int): unused (kept for compatibility).&#10;        content_body (str): content to write into the file.&#10;&#10;    Returns:&#10;        bool: True on success, False on error.&#10;    &quot;&quot;&quot;&#10;    get_file = os.path.basename(path_to_file)&#10;    target_file = os.path.join(directory, get_file)&#10;&#10;    try:&#10;        # Write as text â€“ this mirrors the original simple behaviour.&#10;        with open(target_file, 'w') as file:&#10;            file.write(content_body)&#10;        return True&#10;    except Exception:&#10;        # Swallow exceptions and return False to keep behaviour simple.&#10;        return False&#10;&#10;&#10;def validate_encoding(encoding_type):&#10;    &quot;&quot;&quot;&#10;    Filter a list of Accept-Encoding values and keep supported encodings.&#10;&#10;    Supported encodings in this minimal server are: 'gzip', 'deflate', 'br'.&#10;&#10;    Args:&#10;        encoding_type (list[str]): list of encodings taken from request header.&#10;&#10;    Returns:&#10;        list[str]: filtered list containing only supported encodings.&#10;    &quot;&quot;&quot;&#10;    result = []&#10;    for encoding in encoding_type:&#10;        if encoding in [&quot;gzip&quot;, &quot;deflate&quot;, &quot;br&quot;]:&#10;            result.append(encoding)&#10;    return result&#10;&#10;&#10;def gzip_encode(data):&#10;    &quot;&quot;&quot;&#10;    Compress `data` using gzip.&#10;&#10;    The helper accepts either bytes or str. If a str is provided it will be&#10;    encoded with the default encoding (utf-8) before compression.&#10;&#10;    Returns:&#10;        bytes: gzip-compressed bytes.&#10;    &quot;&quot;&quot;&#10;    compressed_data = gzip.compress(data if isinstance(data, bytes) else data.encode())&#10;    return compressed_data&#10;&#10;&#10;def generate_response(http_method, http_full_path, http_version, host,&#10;                      content_type, content_length, user_agent, request_body, directory, encoding_type, connection):&#10;    &quot;&quot;&quot;&#10;    Build an HTTP response for a single request.&#10;&#10;    This function implements the small set of behaviors required by the&#10;    exercise: serve existing files, echo path segments, return User-Agent,&#10;    handle POST to create files, and return simple status codes.&#10;&#10;    Important: This helper returns raw bytes ready to be sent on the socket.&#10;&#10;    Args (all strings except where noted):&#10;        http_method: 'GET' or 'POST' (others will be ignored by the caller).&#10;        http_full_path: request path from the request-line (e.g. '/foo').&#10;        http_version: HTTP version from request-line (e.g. 'HTTP/1.1').&#10;        host: Host header value or None.&#10;        content_type: Content-Type header value or None.&#10;        content_length: Content-Length header as integer (0 if absent).&#10;        user_agent: User-Agent header value or None.&#10;        request_body: request body as string or None.&#10;        directory: host directory used for file operations.&#10;        encoding_type: list of Accept-Encoding tokens.&#10;        connection: Connection header value or None (e.g. 'close').&#10;&#10;    Returns:&#10;        bytes: full HTTP response (headers + optional body).&#10;    &quot;&quot;&quot;&#10;&#10;    # If client requested connection close, include header in responses.&#10;    connection_close = &quot;&quot;&#10;    if connection == &quot;close&quot;:&#10;        connection_close = &quot;Connection: close\r\n&quot;&#10;&#10;    http_response = b&quot;&quot;&#10;    match http_method:&#10;        case &quot;GET&quot;:&#10;            # Serve file if it exists in the host directory.&#10;            if check_file_exists(http_full_path, directory):&#10;                target_file = os.path.join(directory, os.path.basename(http_full_path))&#10;                http_code = &quot;200 OK&quot;&#10;                # Read as text (keeps original behaviour) and determine length.&#10;                with open(target_file, 'r') as file:&#10;                    response_body = file.read()&#10;                content_type = &quot;application/octet-stream&quot;&#10;                content_length = os.path.getsize(target_file)&#10;&#10;                http_response = (&#10;                    f&quot;{http_version} {http_code}\r\n&quot;&#10;                    f&quot;Content-Type: {content_type}\r\n&quot;&#10;                    f&quot;Content-Length: {content_length}\r\n&quot;&#10;                    f&quot;{connection_close}&quot;&#10;                    f&quot;\r\n&quot;&#10;                    f&quot;{response_body}&quot;&#10;                ).encode()&#10;&#10;            # Simple echo handler: GET /echo/&lt;message&gt;&#10;            elif http_full_path.split(&quot;/&quot;)[1] == &quot;echo&quot;:&#10;                http_code = &quot;200 OK&quot;&#10;                content_type = &quot;text/plain&quot;&#10;                content_length = len(http_full_path.split(&quot;/&quot;)[2])&#10;                response_body = http_full_path.split(&quot;/&quot;)[2]&#10;                encoding_list = validate_encoding(encoding_type)&#10;&#10;                if len(encoding_list) &gt; 0:&#10;                    # compress response when client accepts gzip/deflate/br&#10;                    content_encoding = &quot;, &quot;.join(encoding_list)&#10;                    compresed_body = gzip_encode(response_body)&#10;                    http_response = (&#10;                        f&quot;{http_version} {http_code}\r\n&quot;&#10;                        f&quot;Content-Encoding: {content_encoding}\r\n&quot;&#10;                        f&quot;Content-Type: {content_type}\r\n&quot;&#10;                        f&quot;Content-Length: {len(compresed_body)}\r\n&quot;&#10;                        f&quot;{connection_close}&quot;&#10;                        f&quot;\r\n&quot;&#10;                    ).encode() + compresed_body&#10;                else:&#10;                    http_response = (&#10;                        f&quot;{http_version} {http_code}\r\n&quot;&#10;                        f&quot;Content-Type: {content_type}\r\n&quot;&#10;                        f&quot;Content-Length: {content_length}\r\n&quot;&#10;                        f&quot;{connection_close}&quot;&#10;                        f&quot;\r\n&quot;&#10;                        f&quot;{response_body}&quot;&#10;                    ).encode()&#10;&#10;            # If present, return the User-Agent string as the response body.&#10;            elif user_agent is not None:&#10;                http_code = &quot;200 OK&quot;&#10;                content_type = &quot;text/plain&quot;&#10;                response_body = user_agent&#10;                content_length = len(response_body)&#10;                http_response = (&#10;                    f&quot;{http_version} {http_code}\r\n&quot;&#10;                    f&quot;Content-Type: {content_type}\r\n&quot;&#10;                    f&quot;Content-Length: {content_length}\r\n&quot;&#10;                    f&quot;{connection_close}&quot;&#10;                    f&quot;\r\n&quot;&#10;                    f&quot;{response_body}&quot;&#10;                ).encode()&#10;&#10;            # Root path returns an empty 200 response (keeps original behaviour).&#10;            elif http_full_path == &quot;/&quot;:&#10;                http_code = &quot;200 OK&quot;&#10;&#10;                http_response = (&#10;                    f&quot;{http_version} {http_code}\r\n&quot;&#10;                    f&quot;{connection_close}&quot;&#10;                    f&quot;\r\n&quot;&#10;                ).encode()&#10;            else:&#10;                # Not found&#10;                http_code = &quot;404 Not Found&quot;&#10;                http_response = (&#10;                    f&quot;{http_version} {http_code}\r\n\r\n&quot;&#10;                    f&quot;{connection_close}&quot;&#10;                ).encode()&#10;&#10;        case &quot;POST&quot;:&#10;            # Create a file using the request body.&#10;            if check_directory_exists(directory):&#10;                create_file(http_full_path, directory, content_type, content_length, request_body)&#10;                http_code = &quot;201 Created&quot;&#10;                http_response = (&#10;                    f&quot;{http_version} {http_code}\r\n&quot;&#10;                    f&quot;{connection_close}&quot;&#10;                    f&quot;\r\n&quot;&#10;                ).encode()&#10;&#10;            else:&#10;                http_code = &quot;404 Not Found&quot;&#10;                http_response = (&#10;                    f&quot;{http_version} {http_code}\r\n\r\n&quot;&#10;                    f&quot;{connection_close}&quot;&#10;                ).encode()&#10;&#10;    return http_response&#10;&#10;&#10;def parse_request(request):&#10;    &quot;&quot;&quot;&#10;    Parse a raw HTTP request string into components.&#10;&#10;    This parser is intentionally minimal: it splits headers on CRLF and stops&#10;    parsing headers at the first empty line. It supports extracting a small&#10;    set of headers used by this server (Host, Content-Length, Content-Type,&#10;    User-Agent, Accept-Encoding, Connection).&#10;&#10;    Args:&#10;        request (str): raw HTTP request text (headers + optional body).&#10;&#10;    Returns:&#10;        tuple: (method, path, version, host, content_type, content_length,&#10;                user_agent, request_body, encoding_type_list, connection)&#10;    &quot;&quot;&quot;&#10;    sections = request.split(&quot;\r\n&quot;)&#10;    request_line = sections[0].split(&quot; &quot;)&#10;    method = request_line[0]&#10;    path = request_line[1]&#10;    version = request_line[2]&#10;&#10;    header_host = None&#10;    content_length = 0&#10;    content_type = None&#10;    user_agent = None&#10;    encoding_type = []&#10;    connection = None&#10;    for header in sections[1:]:&#10;        if header == &quot;&quot;:&#10;            break&#10;&#10;        if header.lower().startswith(&quot;host:&quot;):&#10;            header_host = header.split(&quot; &quot;, 1)[1].strip()&#10;        elif header.lower().startswith(&quot;content-length:&quot;):&#10;            content_length = int(header.split(&quot; &quot;, 1)[1].strip())&#10;        elif header.lower().startswith(&quot;content-type:&quot;):&#10;            content_type = header.split(&quot; &quot;, 1)[1].strip()&#10;        elif header.lower().startswith(&quot;user-agent:&quot;):&#10;            user_agent = header.split(&quot; &quot;, 1)[1].strip()&#10;        elif header.lower().startswith(&quot;accept-encoding:&quot;):&#10;            for enc in header.split(&quot; &quot;, 1)[1].strip().split(&quot;,&quot;):&#10;                encoding_type.append(enc.strip())&#10;        elif header.lower().startswith(&quot;connection:&quot;):&#10;            connection = header.split(&quot; &quot;, 1)[1].strip()&#10;&#10;    request_body = request.split(&quot;\r\n\r\n&quot;)[1] if &quot;\r\n\r\n&quot; in request else None&#10;    return method, path, version, header_host, content_type, content_length, user_agent, request_body, encoding_type, connection&#10;&#10;&#10;def handle_client(conn):&#10;    &quot;&quot;&quot;&#10;    Handle a single client TCP connection.&#10;&#10;    The function reads requests from the provided socket in a loop so a single&#10;    TCP connection can be reused for multiple HTTP requests (persistent&#10;    connections). It performs minimal parsing and then calls&#10;    `generate_response` to build the reply which is sent back to the client.&#10;&#10;    Note: This function reads up to 1024 bytes per recv call and treats the&#10;    received chunk as a complete request for the purposes of parsing. That is&#10;    a simplification compared to a full HTTP implementation but sufficient for&#10;    the exercise and tests.&#10;&#10;    Args:&#10;        conn (socket.socket): accepted client socket.&#10;    &quot;&quot;&quot;&#10;    parser = argparse.ArgumentParser()&#10;    parser.add_argument(&quot;--directory&quot;, help=&quot;Host directory filepath&quot;)&#10;    args = parser.parse_args()&#10;&#10;&#10;    while True:&#10;        # Read raw bytes from socket and decode to str. Using .strip() here&#10;        # mirrors the original behaviour but may drop leading/trailing whitespace&#10;        # in the request body; this kept for compatibility with existing tests.&#10;        data = conn.recv(1024).decode().strip()&#10;        if not data:&#10;            print(&quot;1) Connection closed&quot;)&#10;            break&#10;&#10;        (http_method, http_full_path, http_version, host, content_type, content_length, user_agent,&#10;         request_body, encoding_type, connection) = parse_request(data)&#10;&#10;        # Generate the HTTP response (headers + optional body)&#10;        http_response = generate_response(http_method, http_full_path, http_version, host, content_type,&#10;                                          content_length, user_agent, request_body, args.directory, encoding_type, connection)&#10;&#10;        # Send response back to client&#10;        conn.sendall(http_response)&#10;&#10;        # Honor `Connection: close` header by breaking out of request loop.&#10;        if connection == &quot;close&quot;:&#10;            print(&quot;2) Connection close detected, closing connection.&quot;)&#10;            break&#10;&#10;    conn.close()&#10;&#10;&#10;def main():&#10;    # You can use print statements as follows for debugging, they'll be visible when running tests.&#10;    print(&quot;Logs from your program will appear here!&quot;)&#10;&#10;    server_socket = socket.create_server((&quot;localhost&quot;, 4221))&#10;&#10;&#10;    while True:&#10;        conn, addr = server_socket.accept()  # wait for client&#10;&#10;        # Start a new thread to handle the connection so multiple TCP clients&#10;        # can be served concurrently.&#10;        threading.Thread(target=handle_client, args=(conn, )).start()&#10;        print(&quot;Started thread for client:&quot;, addr)&#10;&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>